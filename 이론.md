#Chapter 8 (Pointers)
### 포인터
왼쪽 : L-value(주소) , 오른쪽 : R-value(값)  
포인터 : 값을 다 계속 복사해서 주면 메모리 문제가 생기니깐 주소를 전달해줌 (메모리 추가 사용 X)  
\* : 주소를 값으로 
& : 값을 주소로
nullptr : 포인터 변수 초기화  
배열 : 동일한 data type의 연속적인 메모리 공간  
```cpp
int n[5];
display(n);
void display(int *ptr); 
void display(int ptr[]);
배열을 줄 때 배열의 크기도 주어야함
void display(const int* ptr , const size_t size);
```

### const
const int* ptr : 값을 바꿀 수 없음  
int* const ptr : 주소를 바꿀 수 없음
```cpp
int arr; 
arr == arr[0];
```
# Chapter 9 (Classes : A Deeper Look)

### 헤더파일이 중복되는 것 방지
```cpp
#ifndef ____
#define ____

#endif
```


ostringstream output ~~~~ return output.str()
클래스를 받을땐 주소로 받는다(ex)Time& time)













try-catch문 : 예외처리
생성자 소멸자 순서 : 생성자는 있는 그대로, 소멸자는 그냥 -> static -> 전역 순서
소멸자는 동작할당한 메모리를 해제할 때 쓴다.
객체지향에서의 캡슐화가 깨진다. / 크래킹에서 쓴다.




friend : 멤버변수에 접근할 수 있도록 도와줌
//
this : 객체를 가리키는 주소 포인터
*this : this pointer가 가리키는 객체
Time& setHour(int s){

    return *this;
}
객체의 주소를 넘기는 방법
//
//
클래스에서 static 변수 호출하기
