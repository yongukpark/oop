# Chapter 8 (Pointers)
### 포인터
왼쪽 : L-value(주소) , 오른쪽 : R-value(값)  
포인터 : 값을 다 계속 복사해서 주면 메모리 문제가 생기니깐 주소를 전달해줌 (메모리 추가 사용 X)  
\* : 주소를 값으로 
& : 값을 주소로
nullptr : 포인터 변수 초기화  
배열 : 동일한 data type의 연속적인 메모리 공간  
```cpp
int n[5];
display(n);
void display(int *ptr); 
void display(int ptr[]);
배열을 줄 때 배열의 크기도 주어야함
void display(const int* ptr , const size_t size);
```

### const
const int* ptr : 값을 바꿀 수 없음  
int* const ptr : 주소를 바꿀 수 없음
```cpp
int arr; 
arr == arr[0];
```
# Chapter 9 (Classes : A Deeper Look)

### 헤더파일이 중복되는 것 방지
```cpp
#ifndef TIME_H
#define TIME_H

#endif
```
### ostringstream

```cpp  
ostringstream output;
return output.str()
```
 
### 생성자 소멸자
생성자 순서 : 생성자는 있는 그대로  
소멸자 순서 : 소멸자는 그냥 -> static -> 전역 순서  
소멸자는 동작할당한 메모리를 해제할 때 쓴다.  

### 객체의 주소를 밖으로 주면
객체지향에서의 캡슐화가 깨진다. 
크래킹에서 쓴다.

![image](https://user-images.githubusercontent.com/86973831/145575225-41ff53fd-5625-4f77-94dc-5d5a870fb06b.png)





### friend  
멤버변수에 접근할 수 있도록 도와줌  

### this pointer
this : 객체를 가리키는 주소 포인터  
\*this : this pointer가 가리키는 객체  
객체의 주소를 넘기는 방법 

```cpp
Time& setHour(int s){

    return *this;
}
//클래스를 주고 받을 땐 Time&를 
```
### static

### 작동과정
![image](https://user-images.githubusercontent.com/86973831/145575152-6802abf5-c8dd-49f7-81f4-18e4190cd9fb.png)  
cpp + h -> compiler -> obj -> linker -> exe  

  

# Chapter 10 (Operator Overloading)
### cin, cout 
```cpp
friend ostream& opeartor<<(ostream&, const A&);
friend istream& opeartor>>(istream& A&);

ostream& operator<<(ostream& os, const A& a){
    return os;
}
istream& opeartor>>(istream& is, A& a){
    return is;
}
```

### a++, ++a 
```cpp
Date& operator++();
Date operator++(int);

Date& operator++(){//++a
    this->x++;
    return *this;
}
Date opeartor++(int){//a++
    A tmp = *this;
    this->x++;
    return tmp;
}
``` 

### 복사  생성자  
```cpp
class A{
    int* ptr;
    size_t s;
};

A a = b;
```
a가 b의 힙 주소를 참조한다는 뜻이다
이렇게 할당하게 되면 b의 주소가 사라지면 a가 길을 잃게된다(Dangling point 문제)  
그래서 a는 주소를 따로 할당하고 값만 b에서 가져와야한다

### explicit
생성자 앞에 explicit를 쓰면 자동형 변환을 할 수 없어 에러를 띄운다 (안쓰면 에러 없음)  

# Chapter 11 (Inheritance) 
### 상속
상속 : 부모로 갈수록 추상적이고, 자식으로 갈수록 구체적이다  
상속은 쓸데없는 것도 다 가져온다  
Copy and paste는 가져오고 싶은 것만 가져올 수 있다  
부모의 private는 접근할 수 없다  
직계 부모의 protected는 접근할 수 있다

### Upriding  
같은 이름의 멤버함수 일때 자식의 것이 우선 순위  
자식에 없으면 올라가서 찾음  
 
# Chapter 12 (Polymorphism)
### virtual  
부모객체에 바인딩 된 자식객체의 클래스의 함수를 불러올 수 있게 한다  
바인딩 : 메모리에 올리는 행위(동적 바인딩, 정적 바인딩)
부모에 virtual로 선언된 함수는 자식에서 무조건 구현해야 한다

```cpp
virtual double earnings() const = 0;
```
순수가상함수  
